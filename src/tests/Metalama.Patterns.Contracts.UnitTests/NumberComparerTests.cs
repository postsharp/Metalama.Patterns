// Copyright (c) SharpCrafters s.r.o. See the LICENSE.md file in the root directory of this repository root for details.

using Metalama.Patterns.Contracts.Numeric;
using Xunit;

namespace Metalama.Patterns.Contracts.UnitTests;

public sealed class NumberComparerTests
{
    [Theory]
    [InlineData( (sbyte) 0, long.MaxValue, false )]
    [InlineData( (short) 0, long.MaxValue, false )]
    [InlineData( 0, long.MaxValue, false )]
    [InlineData( 0L, long.MaxValue, false )]
    [InlineData( (byte) 0, long.MaxValue, false )]
    [InlineData( (ushort) 0, long.MaxValue, false )]
    [InlineData( 0UL, long.MaxValue, false )]
    [InlineData( 0D, long.MaxValue, false )]
    [InlineData( (sbyte) 0, long.MinValue, true )]
    [InlineData( (short) 0, long.MinValue, true )]
    [InlineData( 0, long.MinValue, true )]
    [InlineData( 0L, long.MinValue, true )]
    [InlineData( (byte) 0, long.MinValue, true )]
    [InlineData( (ushort) 0, long.MinValue, true )]
    [InlineData( 0UL, long.MinValue, true )]
    [InlineData( 0D, long.MinValue, true )]
    [InlineData( (sbyte) 0, 0, true )]
    [InlineData( (short) 0, 0, true )]
    [InlineData( 0, 0, true )]
    [InlineData( 0L, 0, true )]
    [InlineData( (byte) 0, 0, true )]
    [InlineData( (ushort) 0, 0, true )]
    [InlineData( 0UL, 0, true )]
    [InlineData( 0D, 0, true )]
    [InlineData( sbyte.MinValue, sbyte.MinValue, true )]
    [InlineData( short.MinValue, short.MinValue, true )]
    [InlineData( int.MinValue, int.MinValue, true )]
    [InlineData( long.MinValue, long.MinValue, true )]
    [InlineData( byte.MinValue, byte.MinValue, true )]
    [InlineData( ushort.MinValue, ushort.MinValue, true )]
    [InlineData( uint.MinValue, uint.MinValue, true )]
    [InlineData( ulong.MinValue, ulong.MinValue, true )]
    [InlineData( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [InlineData( short.MinValue + 1, short.MinValue, true )]
    [InlineData( int.MinValue + 1, int.MinValue, true )]
    [InlineData( long.MinValue + 1, long.MinValue, true )]
    [InlineData( byte.MinValue + 1, byte.MinValue, true )]
    [InlineData( ushort.MinValue + 1, ushort.MinValue, true )]
    [InlineData( uint.MinValue + 1, uint.MinValue, true )]
    [InlineData( ulong.MinValue + 1, ulong.MinValue, true )]
    [InlineData( double.MinValue + 1, long.MinValue, false )]
    public void IsGreaterThanLong( object? value, long min, bool expectedValue )
        => Assert.Equal( expectedValue, NumberComparer.IsGreaterThan( value, min )!.Value );

    [Theory]
    [InlineData( (sbyte) 0, long.MaxValue, false )]
    [InlineData( (short) 0, long.MaxValue, false )]
    [InlineData( 0, long.MaxValue, false )]
    [InlineData( 0L, long.MaxValue, false )]
    [InlineData( (byte) 0, long.MaxValue, false )]
    [InlineData( (ushort) 0, long.MaxValue, false )]
    [InlineData( 0UL, long.MaxValue, false )]
    [InlineData( 0D, long.MaxValue, false )]
    [InlineData( (sbyte) 0, long.MinValue, true )]
    [InlineData( (short) 0, long.MinValue, true )]
    [InlineData( 0, long.MinValue, true )]
    [InlineData( 0L, long.MinValue, true )]
    [InlineData( (byte) 0, long.MinValue, true )]
    [InlineData( (ushort) 0, long.MinValue, true )]
    [InlineData( 0UL, long.MinValue, true )]
    [InlineData( 0D, long.MinValue, true )]
    [InlineData( (sbyte) 0, 0, false )]
    [InlineData( (short) 0, 0, false )]
    [InlineData( 0, 0, false )]
    [InlineData( 0L, 0, false )]
    [InlineData( (byte) 0, 0, false )]
    [InlineData( (ushort) 0, 0, false )]
    [InlineData( 0UL, 0, false )]
    [InlineData( 0D, 0, false )]
    [InlineData( sbyte.MinValue, sbyte.MinValue, false )]
    [InlineData( short.MinValue, short.MinValue, false )]
    [InlineData( int.MinValue, int.MinValue, false )]
    [InlineData( long.MinValue, long.MinValue, false )]
    [InlineData( byte.MinValue, byte.MinValue, false )]
    [InlineData( ushort.MinValue, ushort.MinValue, false )]
    [InlineData( uint.MinValue, uint.MinValue, false )]
    [InlineData( ulong.MinValue, ulong.MinValue, false )]
    [InlineData( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [InlineData( short.MinValue + 1, short.MinValue, true )]
    [InlineData( int.MinValue + 1, int.MinValue, true )]
    [InlineData( long.MinValue + 1, long.MinValue, true )]
    [InlineData( byte.MinValue + 1, byte.MinValue, true )]
    [InlineData( ushort.MinValue + 1, ushort.MinValue, true )]
    [InlineData( uint.MinValue + 1, uint.MinValue, true )]
    [InlineData( ulong.MinValue + 1, ulong.MinValue, true )]
    [InlineData( double.MinValue + 1, long.MinValue, false )]
    public void IsStrictlyGreaterThanLong( object? value, long min, bool expectedValue )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlyGreaterThan( value, min )!.Value );

    [Theory]
    [InlineData( (sbyte) 0, long.MinValue, false )]
    [InlineData( (short) 0, long.MinValue, false )]
    [InlineData( 0, long.MinValue, false )]
    [InlineData( 0L, long.MinValue, false )]
    [InlineData( (byte) 0, long.MinValue, false )]
    [InlineData( (ushort) 0, long.MinValue, false )]
    [InlineData( 0UL, long.MinValue, false )]
    [InlineData( 0D, long.MinValue, false )]
    [InlineData( (sbyte) 0, long.MaxValue, true )]
    [InlineData( (short) 0, long.MaxValue, true )]
    [InlineData( 0, long.MaxValue, true )]
    [InlineData( 0L, long.MaxValue, true )]
    [InlineData( (byte) 0, long.MaxValue, true )]
    [InlineData( (ushort) 0, long.MaxValue, true )]
    [InlineData( 0UL, long.MaxValue, true )]
    [InlineData( 0D, long.MaxValue, true )]
    [InlineData( (sbyte) 0, 0, true )]
    [InlineData( (short) 0, 0, true )]
    [InlineData( 0, 0, true )]
    [InlineData( 0L, 0, true )]
    [InlineData( (byte) 0, 0, true )]
    [InlineData( (ushort) 0, 0, true )]
    [InlineData( 0UL, 0, true )]
    [InlineData( 0D, 0, true )]
    [InlineData( sbyte.MaxValue, sbyte.MaxValue, true )]
    [InlineData( short.MaxValue, short.MaxValue, true )]
    [InlineData( int.MaxValue, int.MaxValue, true )]
    [InlineData( long.MaxValue, long.MaxValue, true )]
    [InlineData( byte.MaxValue, byte.MaxValue, true )]
    [InlineData( ushort.MaxValue, ushort.MaxValue, true )]
    [InlineData( uint.MaxValue, uint.MaxValue, true )]
    [InlineData( (ulong) long.MaxValue, long.MaxValue, true )]
    [InlineData( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [InlineData( short.MaxValue - 1, short.MaxValue, true )]
    [InlineData( int.MaxValue - 1, int.MaxValue, true )]
    [InlineData( long.MaxValue - 1, long.MaxValue, true )]
    [InlineData( byte.MaxValue - 1, byte.MaxValue, true )]
    [InlineData( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [InlineData( uint.MaxValue - 1, uint.MaxValue, true )]
    [InlineData( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [InlineData( double.MaxValue - 1, long.MaxValue, false )]
    public void IsSmallerThanLong( object? value, long min, bool expectedValue )
        => Assert.Equal( expectedValue, NumberComparer.IsSmallerThan( value, min )!.Value );

    [Theory]
    [InlineData( (sbyte) 0, long.MinValue, false )]
    [InlineData( (short) 0, long.MinValue, false )]
    [InlineData( 0, long.MinValue, false )]
    [InlineData( 0L, long.MinValue, false )]
    [InlineData( (byte) 0, long.MinValue, false )]
    [InlineData( (ushort) 0, long.MinValue, false )]
    [InlineData( 0UL, long.MinValue, false )]
    [InlineData( 0D, long.MinValue, false )]
    [InlineData( (sbyte) 0, long.MaxValue, true )]
    [InlineData( (short) 0, long.MaxValue, true )]
    [InlineData( 0, long.MaxValue, true )]
    [InlineData( 0L, long.MaxValue, true )]
    [InlineData( (byte) 0, long.MaxValue, true )]
    [InlineData( (ushort) 0, long.MaxValue, true )]
    [InlineData( 0UL, long.MaxValue, true )]
    [InlineData( 0D, long.MaxValue, true )]
    [InlineData( (sbyte) 0, 0, false )]
    [InlineData( (short) 0, 0, false )]
    [InlineData( 0, 0, false )]
    [InlineData( 0L, 0, false )]
    [InlineData( (byte) 0, 0, false )]
    [InlineData( (ushort) 0, 0, false )]
    [InlineData( 0UL, 0, false )]
    [InlineData( 0D, 0, false )]
    [InlineData( sbyte.MaxValue, sbyte.MaxValue, false )]
    [InlineData( short.MaxValue, short.MaxValue, false )]
    [InlineData( int.MaxValue, int.MaxValue, false )]
    [InlineData( long.MaxValue, long.MaxValue, false )]
    [InlineData( byte.MaxValue, byte.MaxValue, false )]
    [InlineData( ushort.MaxValue, ushort.MaxValue, false )]
    [InlineData( uint.MaxValue, uint.MaxValue, false )]
    [InlineData( (ulong) long.MaxValue, long.MaxValue, false )]
    [InlineData( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [InlineData( short.MaxValue - 1, short.MaxValue, true )]
    [InlineData( int.MaxValue - 1, int.MaxValue, true )]
    [InlineData( long.MaxValue - 1, long.MaxValue, true )]
    [InlineData( byte.MaxValue - 1, byte.MaxValue, true )]
    [InlineData( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [InlineData( uint.MaxValue - 1, uint.MaxValue, true )]
    [InlineData( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [InlineData( double.MaxValue - 1, long.MaxValue, false )]
    public void IsStrictlySmallerThanLong( object? value, long min, bool expectedValue )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlySmallerThan( value, min )!.Value );
}