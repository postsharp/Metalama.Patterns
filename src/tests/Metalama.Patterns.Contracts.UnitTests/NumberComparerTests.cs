// Copyright (c) SharpCrafters s.r.o. See the LICENSE.md file in the root directory of this repository root for details.

using Metalama.Patterns.Contracts.Numeric;
using Xunit;

namespace Metalama.Patterns.Contracts.UnitTests;

public sealed class NumberComparerTests
{
    #region Int64

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, short>( 0, long.MaxValue, false )]
    [ConversionTestData<long, int>( 0, long.MaxValue, false )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<long, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<long, short>( 0, long.MinValue, true )]
    [ConversionTestData<long, int>( 0, long.MinValue, true )]
    [ConversionTestData<long, long>( 0L, long.MinValue, true )]
    [ConversionTestData<long, byte>( 0, long.MinValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<long, uint>( 0, long.MinValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<long, double>( 0D, long.MinValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, true )]
    [ConversionTestData<long, short>( 0, 0, true )]
    [ConversionTestData<long, int>( 0, 0, true )]
    [ConversionTestData<long, long>( 0L, 0, true )]
    [ConversionTestData<long, byte>( 0, 0, true )]
    [ConversionTestData<long, ushort>( 0, 0, true )]
    [ConversionTestData<long, uint>( 0, 0, true )]
    [ConversionTestData<long, ulong>( 0UL, 0, true )]
    [ConversionTestData<long, double>( 0D, 0, true )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue, byte.MinValue, true )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue + 1, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<long, ushort>( 1, 0, true )]
    [ConversionTestData<long, uint>( 1, 0, true )]
    [ConversionTestData<long, ulong>( 1, 0, true )]
    [ConversionTestData<long, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionNullTestData<long, double>( double.NaN, long.MaxValue )]
    public void IsGreaterThanInt64( object? value, long min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, short>( 0, long.MaxValue, false )]
    [ConversionTestData<long, int>( 0, long.MaxValue, false )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<long, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<long, short>( 0, long.MinValue, true )]
    [ConversionTestData<long, int>( 0, long.MinValue, true )]
    [ConversionTestData<long, long>( 0L, long.MinValue, true )]
    [ConversionTestData<long, byte>( 0, long.MinValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<long, double>( 0D, long.MinValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, false )]
    [ConversionTestData<long, short>( 0, 0, false )]
    [ConversionTestData<long, int>( 0, 0, false )]
    [ConversionTestData<long, long>( 0L, 0, false )]
    [ConversionTestData<long, byte>( 0, 0, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0UL, 0, false )]
    [ConversionTestData<long, double>( 0D, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue, sbyte.MinValue, false )]
    [ConversionTestData<long, short>( short.MinValue, short.MinValue, false )]
    [ConversionTestData<long, int>( int.MinValue, int.MinValue, false )]
    [ConversionTestData<long, long>( long.MinValue, long.MinValue, false )]
    [ConversionTestData<long, byte>( byte.MinValue, byte.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, uint>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue + 1, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<long, ushort>( 1, 0, true )]
    [ConversionTestData<long, uint>( 1, 0, true )]
    [ConversionTestData<long, ulong>( 1, 0, true )]
    [ConversionTestData<long, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NaN, long.MaxValue )]
    public void IsStrictlyGreaterThanInt64( object? value, long min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlyGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, false )]
    [ConversionTestData<long, short>( 0, long.MinValue, false )]
    [ConversionTestData<long, int>( 0, long.MinValue, false )]
    [ConversionTestData<long, long>( 0L, long.MinValue, false )]
    [ConversionTestData<long, byte>( 0, long.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, false )]
    [ConversionTestData<long, double>( 0D, long.MinValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, short>( 0, long.MaxValue, true )]
    [ConversionTestData<long, int>( 0, long.MaxValue, true )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, true )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, true )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, true )]
    [ConversionTestData<long, short>( 0, 0, true )]
    [ConversionTestData<long, int>( 0, 0, true )]
    [ConversionTestData<long, long>( 0L, 0, true )]
    [ConversionTestData<long, byte>( 0, 0, true )]
    [ConversionTestData<long, ushort>( 0, 0, true )]
    [ConversionTestData<long, ulong>( 0UL, 0, true )]
    [ConversionTestData<long, double>( 0D, 0, true )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue - 1, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MinValue, true )]
    [ConversionNullTestData<long, double>( double.NaN, long.MinValue )]
    public void IsSmallerThanInt64( object? value, long min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsSmallerThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, false )]
    [ConversionTestData<long, short>( 0, long.MinValue, false )]
    [ConversionTestData<long, int>( 0, long.MinValue, false )]
    [ConversionTestData<long, long>( 0L, long.MinValue, false )]
    [ConversionTestData<long, byte>( 0, long.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, false )]
    [ConversionTestData<long, double>( 0D, long.MinValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, short>( 0, long.MaxValue, true )]
    [ConversionTestData<long, int>( 0, long.MaxValue, true )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, true )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, true )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, false )]
    [ConversionTestData<long, short>( 0, 0, false )]
    [ConversionTestData<long, int>( 0, 0, false )]
    [ConversionTestData<long, long>( 0L, 0, false )]
    [ConversionTestData<long, byte>( 0, 0, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0UL, 0, false )]
    [ConversionTestData<long, double>( 0D, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue, sbyte.MaxValue, false )]
    [ConversionTestData<long, short>( short.MaxValue, short.MaxValue, false )]
    [ConversionTestData<long, int>( int.MaxValue, int.MaxValue, false )]
    [ConversionTestData<long, long>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<long, byte>( byte.MaxValue, byte.MaxValue, false )]
    [ConversionTestData<long, ushort>( ushort.MaxValue, ushort.MaxValue, false )]
    [ConversionTestData<long, uint>( uint.MaxValue, uint.MaxValue, false )]
    [ConversionTestData<long, ulong>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue - 1, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MinValue, true )]
    [ConversionNullTestData<long, double>( double.NaN, long.MinValue )]
    public void IsStrictlySmallerThanInt64( object? value, long min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlySmallerThan( value, min )!.Value );

    #endregion

    #region UInt64

    [Theory]
    [ConversionTestData<ulong, sbyte>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, short>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, int>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, long>( 0L, ulong.MaxValue, false )]
    [ConversionTestData<ulong, byte>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, ushort>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, ulong>( 0UL, ulong.MaxValue, false )]
    [ConversionTestData<ulong, double>( 0D, ulong.MaxValue, false )]
    [ConversionTestData<ulong, sbyte>( 0, 0, true )]
    [ConversionTestData<ulong, short>( 0, 0, true )]
    [ConversionTestData<ulong, int>( 0, 0, true )]
    [ConversionTestData<ulong, long>( 0L, 0, true )]
    [ConversionTestData<ulong, byte>( 0, 0, true )]
    [ConversionTestData<ulong, ushort>( 0, 0, true )]
    [ConversionTestData<ulong, ulong>( 0UL, 0, true )]
    [ConversionTestData<ulong, double>( 0D, 0, true )]
    [ConversionTestData<ulong, sbyte>( 0, 0, true )]
    [ConversionTestData<ulong, short>( 0, 0, true )]
    [ConversionTestData<ulong, int>( 0, 0, true )]
    [ConversionTestData<ulong, long>( 0L, 0, true )]
    [ConversionTestData<ulong, byte>( 0, 0, true )]
    [ConversionTestData<ulong, ushort>( 0, 0, true )]
    [ConversionTestData<ulong, ulong>( 0UL, 0, true )]
    [ConversionTestData<ulong, double>( 0D, 0, true )]
    [ConversionTestData<ulong, sbyte>( sbyte.MinValue, 0, false )]
    [ConversionTestData<ulong, short>( short.MinValue, 0, false )]
    [ConversionTestData<ulong, int>( int.MinValue, 0, false )]
    [ConversionTestData<ulong, long>( long.MinValue, 0, false )]
    [ConversionTestData<ulong, uint>( 0, 0, true )]
    [ConversionTestData<ulong, sbyte>( sbyte.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, short>( short.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, int>( int.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, long>( long.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, byte>( byte.MinValue + 1, 0, true )]
    [ConversionTestData<ulong, uint>( 1, 0, true )]
    [ConversionTestData<ulong, ulong>( 1, 0, true )]
    [ConversionTestData<ulong, double>( double.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, double>( double.PositiveInfinity, ulong.MaxValue, true )]
    [ConversionTestData<ulong, double>( double.NegativeInfinity, 0, false )]
    [ConversionNullTestData<ulong, double>( double.NaN, ulong.MaxValue )]
    public void IsGreaterThanUInt64( object? value, ulong min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<ulong, sbyte>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, short>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, int>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, long>( 0L, ulong.MaxValue, false )]
    [ConversionTestData<ulong, byte>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, ushort>( 0, ulong.MaxValue, false )]
    [ConversionTestData<ulong, ulong>( 0UL, ulong.MaxValue, false )]
    [ConversionTestData<ulong, double>( 0D, ulong.MaxValue, false )]
    [ConversionTestData<ulong, sbyte>( 0, 0, false )]
    [ConversionTestData<ulong, short>( 0, 0, false )]
    [ConversionTestData<ulong, int>( 0, 0, false )]
    [ConversionTestData<ulong, long>( 0L, 0, false )]
    [ConversionTestData<ulong, byte>( 0, 0, false )]
    [ConversionTestData<ulong, ushort>( 0, 0, false )]
    [ConversionTestData<ulong, ulong>( 0UL, 0, false )]
    [ConversionTestData<ulong, double>( 0D, 0, false )]
    [ConversionTestData<ulong, sbyte>( sbyte.MinValue, 0, false )]
    [ConversionTestData<ulong, short>( short.MinValue, 0, false )]
    [ConversionTestData<ulong, int>( int.MinValue, 0, false )]
    [ConversionTestData<ulong, long>( long.MinValue, 0, false )]
    [ConversionTestData<ulong, sbyte>( sbyte.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, short>( short.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, int>( int.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, long>( long.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, byte>( byte.MinValue + 1, 0, true )]
    [ConversionTestData<ulong, ushort>( 1, 0, true )]
    [ConversionTestData<ulong, uint>( 1, 0, true )]
    [ConversionTestData<ulong, ulong>( 1, 0, true )]
    [ConversionTestData<ulong, double>( double.MinValue + 1, 0, false )]
    [ConversionTestData<ulong, double>( double.PositiveInfinity, ulong.MaxValue, true )]
    [ConversionTestData<ulong, double>( double.NegativeInfinity, 0, false )]
    [ConversionNullTestData<ulong, double>( double.NaN, ulong.MaxValue )]
    public void IsStrictlyGreaterThanUInt64( object? value, ulong min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlyGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<ulong, sbyte>( 0, 0, true )]
    [ConversionTestData<ulong, short>( 0, 0, true )]
    [ConversionTestData<ulong, int>( 0, 0, true )]
    [ConversionTestData<ulong, long>( 0L, 0, true )]
    [ConversionTestData<ulong, byte>( 0, 0, true )]
    [ConversionTestData<ulong, ushort>( 0, 0, true )]
    [ConversionTestData<ulong, ulong>( 0UL, 0, true )]
    [ConversionTestData<ulong, double>( 0D, 0, true )]
    [ConversionTestData<ulong, sbyte>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, short>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, int>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, long>( 0L, ulong.MaxValue, true )]
    [ConversionTestData<ulong, byte>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, ushort>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, ulong>( 0UL, ulong.MaxValue, true )]
    [ConversionTestData<ulong, double>( 0D, ulong.MaxValue, true )]
    [ConversionTestData<ulong, sbyte>( sbyte.MaxValue, (ulong) sbyte.MaxValue, true )]
    [ConversionTestData<ulong, short>( short.MaxValue, (ulong) short.MaxValue, true )]
    [ConversionTestData<ulong, int>( int.MaxValue, int.MaxValue, true )]
    [ConversionTestData<ulong, long>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<ulong, byte>( byte.MaxValue, byte.MaxValue, true )]
    [ConversionTestData<ulong, ushort>( ushort.MaxValue, ushort.MaxValue, true )]
    [ConversionTestData<ulong, uint>( uint.MaxValue, uint.MaxValue, true )]
    [ConversionTestData<ulong, ulong>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<ulong, sbyte>( sbyte.MaxValue - 1, (ulong) sbyte.MaxValue, true )]
    [ConversionTestData<ulong, short>( short.MaxValue - 1, (ulong) short.MaxValue, true )]
    [ConversionTestData<ulong, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<ulong, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<ulong, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<ulong, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<ulong, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<ulong, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<ulong, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<ulong, double>( double.PositiveInfinity, ulong.MaxValue, false )]
    [ConversionTestData<ulong, double>( double.NegativeInfinity, 0, true )]
    [ConversionNullTestData<ulong, double>( double.NaN, ulong.MaxValue )]
    public void IsSmallerThanUInt64( object? value, ulong min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsSmallerThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<ulong, sbyte>( 0, 0, false )]
    [ConversionTestData<ulong, short>( 0, 0, false )]
    [ConversionTestData<ulong, int>( 0, 0, false )]
    [ConversionTestData<ulong, long>( 0L, 0, false )]
    [ConversionTestData<ulong, byte>( 0, 0, false )]
    [ConversionTestData<ulong, ushort>( 0, 0, false )]
    [ConversionTestData<ulong, ulong>( 0UL, 0, false )]
    [ConversionTestData<ulong, double>( 0D, 0, false )]
    [ConversionTestData<ulong, sbyte>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, short>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, int>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, long>( 0L, ulong.MaxValue, true )]
    [ConversionTestData<ulong, byte>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, ushort>( 0, ulong.MaxValue, true )]
    [ConversionTestData<ulong, ulong>( 0UL, ulong.MaxValue, true )]
    [ConversionTestData<ulong, double>( 0D, ulong.MaxValue, true )]
    [ConversionTestData<ulong, sbyte>( sbyte.MaxValue, (ulong) sbyte.MaxValue, false )]
    [ConversionTestData<ulong, short>( short.MaxValue, (ulong) short.MaxValue, false )]
    [ConversionTestData<ulong, int>( int.MaxValue, int.MaxValue, false )]
    [ConversionTestData<ulong, long>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<ulong, byte>( byte.MaxValue, byte.MaxValue, false )]
    [ConversionTestData<ulong, ushort>( ushort.MaxValue, ushort.MaxValue, false )]
    [ConversionTestData<ulong, uint>( uint.MaxValue, uint.MaxValue, false )]
    [ConversionTestData<ulong, ulong>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<ulong, sbyte>( sbyte.MaxValue - 1, (ulong) sbyte.MaxValue, true )]
    [ConversionTestData<ulong, short>( short.MaxValue - 1, (ulong) short.MaxValue, true )]
    [ConversionTestData<ulong, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<ulong, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<ulong, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<ulong, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<ulong, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<ulong, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<ulong, double>( double.MaxValue - 1, ulong.MaxValue, false )]
    [ConversionTestData<ulong, double>( double.PositiveInfinity, ulong.MaxValue, false )]
    [ConversionTestData<ulong, double>( double.NegativeInfinity, 0, true )]
    [ConversionNullTestData<ulong, double>( double.NaN, ulong.MaxValue )]
    public void IsStrictlySmallerThanUInt64( object? value, ulong min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlySmallerThan( value, min )!.Value );

    #endregion

    #region Double

    [Theory]
    [ConversionTestData<double, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<double, short>( 0, long.MaxValue, false )]
    [ConversionTestData<double, int>( 0, long.MaxValue, false )]
    [ConversionTestData<double, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<double, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<double, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<double, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<double, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<double, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<double, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<double, short>( 0, long.MinValue, true )]
    [ConversionTestData<double, int>( 0, long.MinValue, true )]
    [ConversionTestData<double, long>( 0L, long.MinValue, true )]
    [ConversionTestData<double, byte>( 0, long.MinValue, true )]
    [ConversionTestData<double, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<double, uint>( 0, long.MinValue, true )]
    [ConversionTestData<double, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<double, double>( 0D, long.MinValue, true )]
    [ConversionTestData<double, sbyte>( 0, 0, true )]
    [ConversionTestData<double, short>( 0, 0, true )]
    [ConversionTestData<double, int>( 0, 0, true )]
    [ConversionTestData<double, long>( 0L, 0, true )]
    [ConversionTestData<double, byte>( 0, 0, true )]
    [ConversionTestData<double, ushort>( 0, 0, true )]
    [ConversionTestData<double, uint>( 0, 0, true )]
    [ConversionTestData<double, ulong>( 0UL, 0, true )]
    [ConversionTestData<double, double>( 0D, 0, true )]
    [ConversionTestData<double, sbyte>( sbyte.MinValue, sbyte.MinValue, true )]
    [ConversionTestData<double, short>( short.MinValue, short.MinValue, true )]
    [ConversionTestData<double, int>( int.MinValue, int.MinValue, true )]
    [ConversionTestData<double, long>( long.MinValue, long.MinValue, true )]
    [ConversionTestData<double, byte>( byte.MinValue, byte.MinValue, true )]
    [ConversionTestData<double, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<double, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<double, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<double, long>( long.MinValue + 1, long.MinValue, true )]
    [ConversionTestData<double, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<double, ushort>( 1, 0, true )]
    [ConversionTestData<double, uint>( 1, 0, true )]
    [ConversionTestData<double, ulong>( 1, 0, true )]
    [ConversionTestData<double, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<double, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<double, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionNullTestData<double, double>( double.NaN, long.MaxValue )]
    public void IsGreaterThanDouble( object? value, double min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<double, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<double, short>( 0, long.MaxValue, false )]
    [ConversionTestData<double, int>( 0, long.MaxValue, false )]
    [ConversionTestData<double, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<double, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<double, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<double, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<double, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<double, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<double, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<double, short>( 0, long.MinValue, true )]
    [ConversionTestData<double, int>( 0, long.MinValue, true )]
    [ConversionTestData<double, long>( 0L, long.MinValue, true )]
    [ConversionTestData<double, byte>( 0, long.MinValue, true )]
    [ConversionTestData<double, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<double, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<double, double>( 0D, long.MinValue, true )]
    [ConversionTestData<double, sbyte>( 0, 0, false )]
    [ConversionTestData<double, short>( 0, 0, false )]
    [ConversionTestData<double, int>( 0, 0, false )]
    [ConversionTestData<double, long>( 0L, 0, false )]
    [ConversionTestData<double, byte>( 0, 0, false )]
    [ConversionTestData<double, ushort>( 0, 0, false )]
    [ConversionTestData<double, ulong>( 0UL, 0, false )]
    [ConversionTestData<double, double>( 0D, 0, false )]
    [ConversionTestData<double, sbyte>( sbyte.MinValue, sbyte.MinValue, false )]
    [ConversionTestData<double, short>( short.MinValue, short.MinValue, false )]
    [ConversionTestData<double, int>( int.MinValue, int.MinValue, false )]
    [ConversionTestData<double, long>( long.MinValue, long.MinValue, false )]
    [ConversionTestData<double, byte>( byte.MinValue, byte.MinValue, false )]
    [ConversionTestData<double, ushort>( 0, 0, false )]
    [ConversionTestData<double, uint>( 0, 0, false )]
    [ConversionTestData<double, ulong>( 0, 0, false )]
    [ConversionTestData<double, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<double, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<double, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<double, long>( long.MinValue + 1, long.MinValue, true, 1, ForgiveRoundingError = true )]
    [ConversionTestData<double, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<double, ushort>( 1, 0, true )]
    [ConversionTestData<double, uint>( 1, 0, true )]
    [ConversionTestData<double, ulong>( 1, 0, true )]
    [ConversionTestData<double, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<double, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<double, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionNullTestData<double, double>( double.NaN, long.MaxValue )]
    public void IsStrictlyGreaterThanDouble( object? value, double min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlyGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<double, sbyte>( 0, long.MinValue, false )]
    [ConversionTestData<double, short>( 0, long.MinValue, false )]
    [ConversionTestData<double, int>( 0, long.MinValue, false )]
    [ConversionTestData<double, long>( 0L, long.MinValue, false )]
    [ConversionTestData<double, byte>( 0, long.MinValue, false )]
    [ConversionTestData<double, ushort>( 0, long.MinValue, false )]
    [ConversionTestData<double, ulong>( 0UL, long.MinValue, false )]
    [ConversionTestData<double, double>( 0D, long.MinValue, false )]
    [ConversionTestData<double, sbyte>( 0, long.MaxValue, true )]
    [ConversionTestData<double, short>( 0, long.MaxValue, true )]
    [ConversionTestData<double, int>( 0, long.MaxValue, true )]
    [ConversionTestData<double, long>( 0L, long.MaxValue, true )]
    [ConversionTestData<double, byte>( 0, long.MaxValue, true )]
    [ConversionTestData<double, ushort>( 0, long.MaxValue, true )]
    [ConversionTestData<double, ulong>( 0UL, long.MaxValue, true )]
    [ConversionTestData<double, double>( 0D, long.MaxValue, true )]
    [ConversionTestData<double, sbyte>( 0, 0, true )]
    [ConversionTestData<double, short>( 0, 0, true )]
    [ConversionTestData<double, int>( 0, 0, true )]
    [ConversionTestData<double, long>( 0L, 0, true )]
    [ConversionTestData<double, byte>( 0, 0, true )]
    [ConversionTestData<double, ushort>( 0, 0, true )]
    [ConversionTestData<double, ulong>( 0UL, 0, true )]
    [ConversionTestData<double, double>( 0D, 0, true )]
    [ConversionTestData<double, sbyte>( sbyte.MaxValue, sbyte.MaxValue, true )]
    [ConversionTestData<double, short>( short.MaxValue, short.MaxValue, true )]
    [ConversionTestData<double, int>( int.MaxValue, int.MaxValue, true )]
    [ConversionTestData<double, long>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<double, byte>( byte.MaxValue, byte.MaxValue, true )]
    [ConversionTestData<double, ushort>( ushort.MaxValue, ushort.MaxValue, true )]
    [ConversionTestData<double, uint>( uint.MaxValue, uint.MaxValue, true )]
    [ConversionTestData<double, ulong>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<double, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [ConversionTestData<double, short>( short.MaxValue - 1, short.MaxValue, true )]
    [ConversionTestData<double, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<double, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<double, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<double, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<double, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<double, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<double, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<double, double>( double.PositiveInfinity, long.MaxValue, false )]
    [ConversionTestData<double, double>( double.NegativeInfinity, long.MinValue, true )]
    [ConversionNullTestData<double, double>( double.NaN, long.MinValue )]
    public void IsSmallerThanDouble( object? value, double min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsSmallerThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<double, sbyte>( 0, long.MinValue, false, 1 )]
    [ConversionTestData<double, short>( 0, long.MinValue, false, 2 )]
    [ConversionTestData<double, int>( 0, long.MinValue, false, 3 )]
    [ConversionTestData<double, long>( 0L, long.MinValue, false, 4 )]
    [ConversionTestData<double, byte>( 0, long.MinValue, false, 5 )]
    [ConversionTestData<double, ushort>( 0, long.MinValue, false, 6 )]
    [ConversionTestData<double, ulong>( 0UL, long.MinValue, false, 7 )]
    [ConversionTestData<double, double>( 0D, long.MinValue, false, 8 )]
    [ConversionTestData<double, sbyte>( 0, long.MaxValue, true, 9 )]
    [ConversionTestData<double, short>( 0, long.MaxValue, true, 10 )]
    [ConversionTestData<double, int>( 0, long.MaxValue, true, 11 )]
    [ConversionTestData<double, long>( 0L, long.MaxValue, true, 12 )]
    [ConversionTestData<double, byte>( 0, long.MaxValue, true, 13 )]
    [ConversionTestData<double, ushort>( 0, long.MaxValue, true, 14 )]
    [ConversionTestData<double, ulong>( 0UL, long.MaxValue, true, 15 )]
    [ConversionTestData<double, double>( 0D, long.MaxValue, true, 16 )]
    [ConversionTestData<double, sbyte>( 0, 0, false, 17 )]
    [ConversionTestData<double, short>( 0, 0, false, 18 )]
    [ConversionTestData<double, int>( 0, 0, false, 19 )]
    [ConversionTestData<double, long>( 0L, 0, false, 20 )]
    [ConversionTestData<double, byte>( 0, 0, false, 21 )]
    [ConversionTestData<double, ushort>( 0, 0, false, 22 )]
    [ConversionTestData<double, ulong>( 0UL, 0, false, 23 )]
    [ConversionTestData<double, double>( 0D, 0, false, 24 )]
    [ConversionTestData<double, sbyte>( sbyte.MaxValue, sbyte.MaxValue, false, 25 )]
    [ConversionTestData<double, short>( short.MaxValue, short.MaxValue, false, 26 )]
    [ConversionTestData<double, int>( int.MaxValue, int.MaxValue, false, 27 )]
    [ConversionTestData<double, long>( long.MaxValue, long.MaxValue, false, 28 )]
    [ConversionTestData<double, byte>( byte.MaxValue, byte.MaxValue, false, 29 )]
    [ConversionTestData<double, ushort>( ushort.MaxValue, ushort.MaxValue, false, 30 )]
    [ConversionTestData<double, uint>( uint.MaxValue, uint.MaxValue, false, 31 )]
    [ConversionTestData<double, ulong>( long.MaxValue, long.MaxValue, false, 32 )]
    [ConversionTestData<double, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true, 33 )]
    [ConversionTestData<double, short>( short.MaxValue - 1, short.MaxValue, true, 34 )]
    [ConversionTestData<double, int>( int.MaxValue - 1, int.MaxValue, true, 35 )]
    [ConversionTestData<double, byte>( byte.MaxValue - 1, byte.MaxValue, true, 37 )]
    [ConversionTestData<double, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true, 38 )]
    [ConversionTestData<double, uint>( uint.MaxValue - 1, uint.MaxValue, true, 39 )]
    [ConversionTestData<double, double>( double.MaxValue - 1, long.MaxValue, false, 41 )]
    [ConversionTestData<double, double>( double.PositiveInfinity, long.MaxValue, false, 42 )]
    [ConversionTestData<double, double>( double.NegativeInfinity, long.MinValue, true, 43 )]
    [ConversionNullTestData<double, double>( double.NaN, long.MinValue )]
    [ConversionTestData<double, long>( long.MaxValue - 1, long.MaxValue, true, 36, ForgiveRoundingError = true )]
    [ConversionTestData<double, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true, 40, ForgiveRoundingError = true )]
    public void IsStrictlySmallerThanDouble( object? value, double min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlySmallerThan( value, min )!.Value );

    #endregion

    #region Decimal

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, short>( 0, long.MaxValue, false )]
    [ConversionTestData<long, int>( 0, long.MaxValue, false )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<long, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<long, short>( 0, long.MinValue, true )]
    [ConversionTestData<long, int>( 0, long.MinValue, true )]
    [ConversionTestData<long, long>( 0L, long.MinValue, true )]
    [ConversionTestData<long, byte>( 0, long.MinValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<long, uint>( 0, long.MinValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<long, double>( 0D, long.MinValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, true )]
    [ConversionTestData<long, short>( 0, 0, true )]
    [ConversionTestData<long, int>( 0, 0, true )]
    [ConversionTestData<long, long>( 0L, 0, true )]
    [ConversionTestData<long, byte>( 0, 0, true )]
    [ConversionTestData<long, ushort>( 0, 0, true )]
    [ConversionTestData<long, uint>( 0, 0, true )]
    [ConversionTestData<long, ulong>( 0UL, 0, true )]
    [ConversionTestData<long, double>( 0D, 0, true )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue, byte.MinValue, true )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue + 1, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<long, ushort>( 1, 0, true )]
    [ConversionTestData<long, uint>( 1, 0, true )]
    [ConversionTestData<long, ulong>( 1, 0, true )]
    [ConversionTestData<long, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionNullTestData<long, double>( double.NaN, long.MaxValue )]
    public void IsGreaterThanDecimal( object? value, decimal min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, short>( 0, long.MaxValue, false )]
    [ConversionTestData<long, int>( 0, long.MaxValue, false )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, false )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, false )]
    [ConversionTestData<long, uint>( 0, long.MaxValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, false )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, true )]
    [ConversionTestData<long, short>( 0, long.MinValue, true )]
    [ConversionTestData<long, int>( 0, long.MinValue, true )]
    [ConversionTestData<long, long>( 0L, long.MinValue, true )]
    [ConversionTestData<long, byte>( 0, long.MinValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, true )]
    [ConversionTestData<long, double>( 0D, long.MinValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, false )]
    [ConversionTestData<long, short>( 0, 0, false )]
    [ConversionTestData<long, int>( 0, 0, false )]
    [ConversionTestData<long, long>( 0L, 0, false )]
    [ConversionTestData<long, byte>( 0, 0, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0UL, 0, false )]
    [ConversionTestData<long, double>( 0D, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue, sbyte.MinValue, false )]
    [ConversionTestData<long, short>( short.MinValue, short.MinValue, false )]
    [ConversionTestData<long, int>( int.MinValue, int.MinValue, false )]
    [ConversionTestData<long, long>( long.MinValue, long.MinValue, false )]
    [ConversionTestData<long, byte>( byte.MinValue, byte.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, uint>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MinValue + 1, sbyte.MinValue, true )]
    [ConversionTestData<long, short>( short.MinValue + 1, short.MinValue, true )]
    [ConversionTestData<long, int>( int.MinValue + 1, int.MinValue, true )]
    [ConversionTestData<long, long>( long.MinValue + 1, long.MinValue, true )]
    [ConversionTestData<long, byte>( byte.MinValue + 1, byte.MinValue, true )]
    [ConversionTestData<long, ushort>( 1, 0, true )]
    [ConversionTestData<long, uint>( 1, 0, true )]
    [ConversionTestData<long, ulong>( 1, 0, true )]
    [ConversionTestData<long, double>( double.MinValue + 1, long.MinValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NaN, long.MaxValue )]
    public void IsStrictlyGreaterThanDecimal( object? value, decimal min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlyGreaterThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, false )]
    [ConversionTestData<long, short>( 0, long.MinValue, false )]
    [ConversionTestData<long, int>( 0, long.MinValue, false )]
    [ConversionTestData<long, long>( 0L, long.MinValue, false )]
    [ConversionTestData<long, byte>( 0, long.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, false )]
    [ConversionTestData<long, double>( 0D, long.MinValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, short>( 0, long.MaxValue, true )]
    [ConversionTestData<long, int>( 0, long.MaxValue, true )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, true )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, true )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, true )]
    [ConversionTestData<long, short>( 0, 0, true )]
    [ConversionTestData<long, int>( 0, 0, true )]
    [ConversionTestData<long, long>( 0L, 0, true )]
    [ConversionTestData<long, byte>( 0, 0, true )]
    [ConversionTestData<long, ushort>( 0, 0, true )]
    [ConversionTestData<long, ulong>( 0UL, 0, true )]
    [ConversionTestData<long, double>( 0D, 0, true )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( long.MaxValue, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue - 1, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MinValue, true )]
    [ConversionNullTestData<long, double>( double.NaN, long.MinValue )]
    public void IsSmallerThanDecimal( object? value, decimal min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsSmallerThan( value, min )!.Value );

    [Theory]
    [ConversionTestData<long, sbyte>( 0, long.MinValue, false )]
    [ConversionTestData<long, short>( 0, long.MinValue, false )]
    [ConversionTestData<long, int>( 0, long.MinValue, false )]
    [ConversionTestData<long, long>( 0L, long.MinValue, false )]
    [ConversionTestData<long, byte>( 0, long.MinValue, false )]
    [ConversionTestData<long, ushort>( 0, long.MinValue, false )]
    [ConversionTestData<long, ulong>( 0UL, long.MinValue, false )]
    [ConversionTestData<long, double>( 0D, long.MinValue, false )]
    [ConversionTestData<long, sbyte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, short>( 0, long.MaxValue, true )]
    [ConversionTestData<long, int>( 0, long.MaxValue, true )]
    [ConversionTestData<long, long>( 0L, long.MaxValue, true )]
    [ConversionTestData<long, byte>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ushort>( 0, long.MaxValue, true )]
    [ConversionTestData<long, ulong>( 0UL, long.MaxValue, true )]
    [ConversionTestData<long, double>( 0D, long.MaxValue, true )]
    [ConversionTestData<long, sbyte>( 0, 0, false )]
    [ConversionTestData<long, short>( 0, 0, false )]
    [ConversionTestData<long, int>( 0, 0, false )]
    [ConversionTestData<long, long>( 0L, 0, false )]
    [ConversionTestData<long, byte>( 0, 0, false )]
    [ConversionTestData<long, ushort>( 0, 0, false )]
    [ConversionTestData<long, ulong>( 0UL, 0, false )]
    [ConversionTestData<long, double>( 0D, 0, false )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue, sbyte.MaxValue, false )]
    [ConversionTestData<long, short>( short.MaxValue, short.MaxValue, false )]
    [ConversionTestData<long, int>( int.MaxValue, int.MaxValue, false )]
    [ConversionTestData<long, long>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<long, byte>( byte.MaxValue, byte.MaxValue, false )]
    [ConversionTestData<long, ushort>( ushort.MaxValue, ushort.MaxValue, false )]
    [ConversionTestData<long, uint>( uint.MaxValue, uint.MaxValue, false )]
    [ConversionTestData<long, ulong>( long.MaxValue, long.MaxValue, false )]
    [ConversionTestData<long, sbyte>( sbyte.MaxValue - 1, sbyte.MaxValue, true )]
    [ConversionTestData<long, short>( short.MaxValue - 1, short.MaxValue, true )]
    [ConversionTestData<long, int>( int.MaxValue - 1, int.MaxValue, true )]
    [ConversionTestData<long, long>( long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, byte>( byte.MaxValue - 1, byte.MaxValue, true )]
    [ConversionTestData<long, ushort>( ushort.MaxValue - 1, ushort.MaxValue, true )]
    [ConversionTestData<long, uint>( uint.MaxValue - 1, uint.MaxValue, true )]
    [ConversionTestData<long, ulong>( (ulong) long.MaxValue - 1, long.MaxValue, true )]
    [ConversionTestData<long, double>( double.MaxValue - 1, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.PositiveInfinity, long.MaxValue, false )]
    [ConversionTestData<long, double>( double.NegativeInfinity, long.MinValue, true )]
    [ConversionNullTestData<long, double>( double.NaN, long.MinValue )]
    public void IsStrictlySmallerThanDecimal( object? value, decimal min, bool expectedValue, object? tag )
        => Assert.Equal( expectedValue, NumberComparer.IsStrictlySmallerThan( value, min )!.Value );

    #endregion
}